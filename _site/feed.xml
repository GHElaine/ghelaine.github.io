<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Elaine&#39;s Blog</title>
    <description>Leave something behind, keep moving forward.
</description>
    <link>http://yourdomain.com/</link>
    <atom:link href="http://yourdomain.com/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 18 Dec 2014 02:34:14 +0800</pubDate>
    <lastBuildDate>Thu, 18 Dec 2014 02:34:14 +0800</lastBuildDate>
    <generator>Jekyll v2.5.2</generator>
    
      <item>
        <title>git使用心得（1）</title>
        <description>&lt;h1 id=&quot;git1--gitignore&quot;&gt;git使用心得（1）- “.gitignore”&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @ 2014-12-18&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;今天无意间看自己的github上socket编程的练习代码库，发现好多无用的可执行文件，于是想要将这些可执行文件忽略，就这么简单的一件事，折腾了将近两个小时。下面来记录一下心得，有些坑，踩一次就该把它填平了。  &lt;/p&gt;

&lt;p&gt;很明显，这事情.gitignore文件做起来最合适了。毫无疑问要修改这个文件。那么问题来了…  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;什么情况下.gitignore是不起作用的？&lt;/strong&gt;&lt;br /&gt;
当第一次配置仓库的时候，没有把.gitignore文件配置合适，已经push过代码了，那么已经被跟踪的文件，.gitignore是无力忽略的。因此，初始化仓库的时候，应该有两个文件是被“习惯性添加”的，一个是“README.md”，另一个就是“.gitignore”。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果初始化的时候就是没配置好怎么办？我就是任性想修改忽略规则怎么办？&lt;/strong&gt;   &lt;br /&gt;
1、&lt;code&gt;git rm -r --cached . &lt;/code&gt; 可以帮助删除当前本地库中所有的文件跟踪，也就是缓存，但不会删除本地库中的代码。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/gitignore1.png&quot; alt=&quot;image&quot; /&gt;   &lt;/p&gt;

&lt;p&gt;2、&lt;code&gt;vi .gitignore&lt;/code&gt; 修改.gitignore文件。记得保存。&lt;br /&gt;
3、&lt;code&gt;git add . &lt;/code&gt; 不解释。&lt;br /&gt;
4、&lt;code&gt;git commit -m &quot;restart .gitignore&quot;&lt;/code&gt;提交一次，此时.gitignore的新规则就生效了。  &lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意，此处有坑！&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;如果在上述步骤2过后，你不小心忽略了3直接执行了4，你会发现，你的代码库里的代码，被全部delete了。&lt;/strong&gt; &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/gitignore2.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然错误已经铸成，就只能把还没同步的代码（其实是workspace现有的所有代码），&lt;code&gt;git add . &lt;/code&gt;重新加进跟踪吧… &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/gitignore4.png&quot; alt=&quot;image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;多亏我这个workspace只是用来存一些小代码，基本不存在版本控制的问题否则的话，呵呵…    &lt;/p&gt;

&lt;p&gt;其实误操作导致的代码被删除，还是可以通过撤销commit找回来的。具体方法在这&lt;a href=&quot;http://git-scm.com/book/zh/ch9-7.html&quot;&gt;git数据维护及恢复&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;说说.gitignore文件里面写什么&lt;/strong&gt; &lt;br /&gt;
* 忽略某些后缀的文件（比如.exe）：*.exe&lt;br /&gt;
* 忽略某个文件夹中的所有文件（比如文件夹a下）：a/*&lt;br /&gt;
* 指定跟踪某个后缀的文件（比如.cpp），即使文件所在位置的其他文件都被忽略：!*.cpp&lt;br /&gt;
* 说个特殊的，整个workspace中，只想跟踪某指定类型的文件（比如.cpp）：    &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /*   
    !*.cpp
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
&lt;p&gt;嗯，现在愈发觉得git是个好东西了。觉得不好用的时候，是自己没用熟练，也没习惯而已。还是玩不转，还是有很多坑等着我去踩，还是慢慢来吧。&lt;/p&gt;

</description>
        <pubDate>Thu, 18 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/12/18/git1.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/12/18/git1.html</guid>
        
        
      </item>
    
      <item>
        <title>繁华落尽，一地金黄</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;繁华落尽，一地金黄&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @ 2014-12-13  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最近我才知道，学校里那条被我一直固执的称作“银杏大道”的路，原来大名叫“绿杨路”。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/campus1.jpg&quot; alt=&quot;image&quot; /&gt;  &lt;/p&gt;

&lt;p&gt;这是我在成都的最后一个冬天了。原来再久再长的时间，都有过完的一天，这七年的异乡求学路，终于也看到了头。   &lt;/p&gt;

&lt;p&gt;我从未像今年一样这样在意这条路上的银杏，虽然它们一直都很美。每年初春，一冬天的蛰伏换来新生的嫩芽，绿的让人怜惜。然后在盛夏枝繁叶茂起来，高而挺拔的一树翠绿，满眼尽是无限生机。十一月的川大里，这条路上的银杏造就了川大最美的风景，每天都有无数新人在这里拍婚纱，偶尔起风，漫天飞扬的金色叶片，如同蝴蝶盘旋在一对对新婚燕尔的身旁，白色的婚纱，温柔的笑颜，眼里眉间都是幸福的味道。我不记得他们的脸，却记得他们发自内心的笑容，映的银杏都醉了。   &lt;/p&gt;

&lt;p&gt;曾经见到一对情侣在银杏树下忘情相拥，天气不好，没有阳光，却有风将树上的残叶催了下来。女孩的脸埋在男孩的肩头，我几乎看得到她被风扬起的发，在漫天的银杏叶中，那么让人怜惜。我远远望着，画面太过美好，不敢打扰，心里却多的是感慨和一丝不易察觉的异样——这样的意境这般的风景，终究是被我辜负了。  &lt;/p&gt;

&lt;p&gt;同样的地点，某天有一对拍婚纱照的情侣。女主角的脸抬起来，被光打的有些恍惚不清，洁白的婚纱铺在一地金黄的银杏叶上，摄影师用专注而奇怪的姿势努力捕捉她最美的样子。几声快门后，旁边冲上来的是抓着棉衣的男主角，他半跪在女生身边，轻轻又急切的为她裹上棉衣，搓搓已经晾了许久的胳膊。认真又温柔的样子，满眼都写着爱意。若不是他，我几乎忘了这是已经入冬的光景。&lt;/p&gt;

&lt;p&gt;深秋时节，每当天公稍稍开恩，阳光普照的日子，这条路上便挤满了前来拍照的人们。带着他们撒欢的小狗，牵着又蹦又跳的调皮孩子，举起相机，镜头前都是喜笑颜开的样子。   &lt;/p&gt;

&lt;p&gt;今天再来这路上，已冷清许久。像是一场散场后的电影，没有彩蛋，片尾曲不咸不淡，不紧不慢。树上的金黄所剩无几，地上的落叶早已被勤劳的环卫工人清理干净，剩下几株倔强的留着黄叶，像是在等着我来为它们伤感。  &lt;/p&gt;

&lt;p&gt;灿烂时，无尽辉煌，目之所及都是欢喜的姿态，凋敝时，枯枝残叶，环顾四周唯有耳机里传来平静的歌声。   &lt;/p&gt;

&lt;p&gt;这是我看的最后一季川大的银杏了。  &lt;/p&gt;

&lt;p&gt;还好，早在意识到即将失去的时候，已经拍下了不少照片，甚至也不惜走进镜头，破坏上佳的美景，只为了证明，真的来过。这三年的光阴过了，总要留下些证据在手里，某天回头，问自己，这段青春，到底是荒芜了否？  &lt;/p&gt;

&lt;p&gt;路过的风景，总在那些过去的路上。你知道它们都在，却被时光拉去了反方向，你不能回头，你知道即使走回去，也见不到它们了，因为已经不再是同一个时空，你已不是当年看风景的你了。就让它们把最美的时刻留在你的记忆里，至少，你还会怀念。 &lt;/p&gt;

&lt;p&gt;繁华落尽，一地金黄。那些年年岁岁都执着的一枯一荣的银杏啊，别人的风景里，你努力的美过了，像是一棵开了花的树，不辜负那些为你举起相机的人们，珍惜那些相识的缘分。等到漫长而寒冷的冬天到来的时候，你在他们的记忆里，点缀着他们的生活，他们在你的记忆里，温暖着你的心窝。&lt;/p&gt;
</description>
        <pubDate>Sat, 13 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/12/13/yidijinhuang.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/12/13/yidijinhuang.html</guid>
        
        
      </item>
    
      <item>
        <title>《黑客与画家》 读后感</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;《黑客与画家》 读后感&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @2014-12-12  &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;终于用了将近一个月时间，把这本被无数人推荐的《黑客与画家》翻完了。说实话，颠覆了我很多的认识，却有更多的地方说到了心坎上。   &lt;/p&gt;

&lt;p&gt;这位硅谷创业之父的很多言论在我看来是有些激进的，但是他强大的逻辑让我没法不信服。搞这行的，果然是靠逻辑吃饭的。   &lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;黑客——“酷”的代名词&lt;/h3&gt;
&lt;p&gt;虽然从来没有觉得“黑客”是个贬义词，却从来也没有像现在这样想要成为一个Hacker。我周围多的是“程序猿”，我同样也没觉得这是个贬义词，不过是一群IT技术人员的自嘲，不过这里面确实有一大帮是普通的码农，而其他少数，则是Hacker们谦虚的自称。这就是保罗·格雷厄姆所说的那些不甘平庸，追求自由和刺激，猎奇而又叛逆的家伙们。这帮人简直酷毙了。&lt;/p&gt;

&lt;p&gt;此时不禁想起亚伦·斯沃兹。这位天才黑客的自杀引起了轩然大波，我想做我们这行的，应该没有人对他不是心怀敬意，为之惋惜吧。作为一个典型的黑客，他就是格雷厄姆所说的那种，不服管教，天资聪颖，不喜欢被人设限的天才。&lt;/p&gt;

&lt;p&gt;我想，或许黑客天生就是激进分子，而他们的激进，正是推动整个行业技术迅猛发展的动力。 &lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;程序是写给人看的&lt;/h3&gt;
&lt;p&gt;保罗在书中引用了一句&lt;strong&gt;“程序是写给人看的，顺带能在机器上运行”&lt;/strong&gt;，实在感同身受，便写在了实验室的电脑桌面上。我想应该有不少人都有过“改别人的代码不如自己重写”的经历，大家都只顾着自己负责的程序，点击运行的时候，能够正常的跑出结果，才不会管什么维护什么扩展。在大学的实验室，这点尤其明显。因为绝绝大多数人，都是完全没有工程经验，没写过太多代码的学生。能把代码跑出正确的结果已经是谢天谢地了。   &lt;/p&gt;

&lt;p&gt;然而这一点，可能正是真正优秀的程序员与普通的程序员的差别。这里说的是程序员，不是黑客。曾经在鹅厂实习的时候，某天某大boss说，鹅厂庞大的代码库里，有那么一行代码是谁都不敢碰的，是一个大神写的一行perl语句，但是没有注释，没有人看得懂，没有人敢动。我想，保罗应该是喜欢perl的吧，比起C++，估计绝大多数具有黑客潜质的程序员，也不会觉得C++比perl酷吧。其实无关语言，代码就是应该让别人看着舒服，不论是注释还是缩进命名风格等等。这也是所有大公司几乎都有自己编程规范的原因吧。而这点，必须从一开始写代码就注意去养成习惯。此处必须感谢李大师，曾在深夜三四点阅读我submit的代码，然后勒令我必须把缩进和命名写规范了，包括运算符两边的空格。现在写的代码，勉强可以看。  &lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;关于贫富差距&lt;/h3&gt;
&lt;p&gt;首先必须要感谢保罗在书中有这样的一章阐述。&lt;/p&gt;

&lt;p&gt;这可能是全书带给我的震撼最大的一章了。&lt;strong&gt;财富是可以创造出来的，而不是一个固定值用来平均分的。&lt;/strong&gt;因此，如果不计贪污腐败，贫富差距并不是坏事，因为富有的人创造了财富，而这些创造财富的人们，真正推动了社会的进步，这才是真正意义上的“多劳多得”吧？  &lt;/p&gt;

&lt;p&gt;当我从小到大形成的观念和“被教育”的思想，受到这样不同观点的冲击的时候，我才意识到其实有很多困惑，我只是没有去深究过，而被保罗这样提出的时候，我才发现，我很轻易的就被他说服了。贫富差距不但不是坏事，甚至可能是社会进步的动力。有些理想，之所以称之为理想，恐怕只是好心人想要把大家团结在一起，至于理想什么时候实现，只能说，现在的阶段任务还没完成，革命尚未成功，同志仍需努力，其他的，就不要想太多了。   &lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;不甘平庸&lt;/h3&gt;
&lt;p&gt;黑客永远喜欢在不经意的时候从天而降，在别人最不设防的时候突然造访，留下点属于自己的痕迹，或者干脆什么也不干，然后绝尘而去，挥一挥衣袖，不带走一片云彩。  &lt;/p&gt;

&lt;p&gt;因为他们不走寻常路，因为他们，“天生骄傲”，不甘平庸。做不平庸的事，用不平庸的方式。&lt;/p&gt;

&lt;p&gt;在我所生活的这二十多年间，正是人们深深感慨“科技改变生活”的时代。谁能想过手机不再是打电话的工具，而称为了生活不可分割的一部分，互联网，让我所认识的世界与父辈大为不同。这些便捷，归功于那些不甘平庸的黑客，他们不设限的思维，让我的生活每天都充满着新鲜和期待。没有做不到，只有想不到，尤其是对一群智商卓群的家伙来说。拥抱变化，可能也是“不甘平庸”的另一种行动吧。&lt;/p&gt;

&lt;p&gt;保罗的不甘平庸，绕不过Lisp，这包含在“不采取平庸的方式”解决问题。他对Lisp的极度推崇几乎达到了狂热的地步。他这么盛赞的语言，当然不能不去领略一二。  &lt;/p&gt;

&lt;h3 id=&quot;section-5&quot;&gt;黑客与画家&lt;/h3&gt;
&lt;p&gt;编程是门艺术。&lt;br /&gt;
而大多数码农，都自甘平庸的认为，这是门糊口的技术。&lt;strong&gt;“我们不创造代码，我们只是代码的搬运工”。&lt;/strong&gt;&lt;br /&gt;
听说每个人心里，其实都住着一个艺术家，做着一个艺术家的梦。有一天，编程，或者软件，可以成为一门艺术那样的令人赞叹，有着让人惊艳的设计，或是给人非同凡响的体验，这应该是每个黑客的艺术家之梦吧。  &lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;section-6&quot;&gt;但愿今日我所说的“他们”，有朝一日可以变成“我们”。&lt;/h4&gt;

</description>
        <pubDate>Fri, 12 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/12/12/hacker.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/12/12/hacker.html</guid>
        
        
      </item>
    
      <item>
        <title>Socket API 编程实践（1）</title>
        <description>&lt;h1 id=&quot;socket-api-1&quot;&gt;Socket API 编程实践（1）&lt;/h1&gt;

&lt;h2 id=&quot;section&quot;&gt;这集副标题是 &lt;em&gt;菜鸟的丢人史&lt;/em&gt;&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @ 2014-12-9   &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这几天看论文看的有些头痛，想着还是写写代码轻松一下，没想到还是遇到了各种问题。作为一个初学Linux网络编程的菜鸟，表示有些东西，理论背的再熟练，都不及动手写一个代码长记性。   &lt;/p&gt;

&lt;p&gt;这段时间，《Linux高性能服务器编程》看到了第五章，深感唯有动手编码才能领会各种协议和Socket的精髓。抄了书上几个例子，竟然有因为抄错代码运行不出正确结果而纠结了一天的荒唐事发生，真是无颜号称自己是计算机专业的学生。究其原因，无非是自己只是把书上的理论看过了，却没能实际理解，抄了书上的代码，却没有逐句去琢磨每行代码的作用。   &lt;/p&gt;

&lt;p&gt;今晚，想着从书上给的TCP的发送/接收数据的例子稍微扩展一下，写个UDP的玩玩，本想着完全没有难度，因为Socket API几乎已经完成了绝绝大多数工作，只需要把逻辑理清楚就行了。结果……啊唏……  &lt;/p&gt;

&lt;p&gt;先说我理解的&lt;strong&gt;TCP发送和接收数据&lt;/strong&gt;的过程：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;发送端：  &lt;/p&gt;

    &lt;p&gt;1.读取服务器（目的主机）IP，Port，转换为&lt;code&gt;sockaddr_in&lt;/code&gt;。这里注意三个字段：&lt;code&gt;sin_family&lt;/code&gt;, &lt;code&gt;sin_addr&lt;/code&gt;, &lt;code&gt;sin_port&lt;/code&gt;: TCP/IP协议族的&lt;code&gt;sin_family&lt;/code&gt;指定为&lt;code&gt;AF_INET&lt;/code&gt;； &lt;code&gt;sin_addr&lt;/code&gt;才是真正存放转换后的IP地址的字段； &lt;code&gt;sin_port&lt;/code&gt;存放转换后的端口号。（&lt;strong&gt;转换指转为网络字节序&lt;/strong&gt;） &lt;br /&gt;
  2.建立Socket。&lt;code&gt;socket&lt;/code&gt;系统调用，第二个参数指定为&lt;code&gt;SOCK_STREAM&lt;/code&gt;时为TCP协议，数据流。 返回值非负时成功建立socket。&lt;br /&gt;
  3.请求连接。&lt;code&gt;connect&lt;/code&gt;系统调用，返回值小于0时，连接失败。否则即可发送数据，&lt;strong&gt;此时三次握手已经完成&lt;/strong&gt;。&lt;br /&gt;
  4.发送数据。&lt;code&gt;send&lt;/code&gt;系统调用，可发送&lt;code&gt;normal_data&lt;/code&gt;（正常数据）和&lt;code&gt;oob_data&lt;/code&gt;（TCP带外数据，紧急数据）。
  5.数据发完，关闭连接。  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接收端：&lt;br /&gt;
  1.读取服务器程序IP，Port，转换为&lt;code&gt;sockadd_in&lt;/code&gt;。注意字段同发送端。&lt;br /&gt;
  2.建立socket，&lt;code&gt;socket&lt;/code&gt;系统调用。 &lt;br /&gt;
  3.绑定地址。&lt;code&gt;bind&lt;/code&gt;系统调用，绑定&lt;code&gt;sockfd&lt;/code&gt;与服务器程序地址（&lt;code&gt;sockadd_in&lt;/code&gt;类型的地址）。&lt;br /&gt;
  4.监听端口。&lt;code&gt;listen&lt;/code&gt;系统调用。监听服务器程序所在端口（根据&lt;code&gt;sockfd&lt;/code&gt;）。
  5.接受连接。&lt;code&gt;accept&lt;/code&gt;系统调用。&lt;strong&gt;此时三次握手至少已完成前两次握手&lt;/strong&gt;。&lt;br /&gt;
  6.接受数据。&lt;code&gt;recv&lt;/code&gt;系统调用。第三个参数可选&lt;code&gt;MSG_OOB&lt;/code&gt;表示带外紧急数据，0表示普通数据。 &lt;br /&gt;
  7.数据传送结束，关闭连接。    &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;今天写的UDP传送数据的过程与TCP过程有相似之处，但有巨大的差异，建立socket的参数不同，发送接收的系统调用函数不同，不再赘述。&lt;br /&gt;
两个协议虽然逻辑都不复杂，差异也很明显：&lt;strong&gt;TCP面向连接，数据可靠，基于字节流；而UDP无连接，不可靠，基于数据报&lt;/strong&gt;。但是写起代码来，居然忘了这些，只一味模仿TCP，简直汗颜。直到代码运行后，始终在listen之后提示错误，半天才意识到，UDP是无连接的，不用侦听端口，只需要绑定地址之后就开始传送数据了，自然也不存在接收端的接受连接，和发送端的请求连接。  &lt;/p&gt;

&lt;p&gt;为了提醒自己UDP无连接的特性，还是将代码中错误的部分保留，仅用注释标记：   &lt;/p&gt;

&lt;pre&gt;&lt;code&gt;	// SEND 
	#include &amp;lt;sys/types.h&amp;gt;
	#include &amp;lt;sys/socket.h&amp;gt;
	#include &amp;lt;libgen.h&amp;gt;
	#include &amp;lt;assert.h&amp;gt;
	#include &amp;lt;errno.h&amp;gt;
	#include &amp;lt;stdlib.h&amp;gt;
	#include &amp;lt;stdio.h&amp;gt;
	#include &amp;lt;netinet/in.h&amp;gt;
	#include &amp;lt;arpa/inet.h&amp;gt;
	#include &amp;lt;unistd.h&amp;gt;
	#include &amp;lt;string.h&amp;gt;

	#define BUFFER_SIZE 1024

	int main(int argc, char* argv[]) {
		if (argc &amp;lt;= 2) {
			printf (&quot;usage: %s ip_address, port number.\n&quot;, basename(argv[0]));
			return 1;
		}
		
		int port = atoi(argv[2]);
		const char* ip = argv[1];

		struct sockaddr_in address;
		bzero(&amp;amp;address, sizeof(address));
		address.sin_family = AF_INET;
		inet_pton(AF_INET, ip, &amp;amp;address.sin_addr);
		address.sin_port = htons(port);

		int sockfd = socket(PF_INET, SOCK_DGRAM, 0);
		assert(sockfd &amp;gt;= 0);

		
		/* if (connect(sockfd, (struct sockaddr*)&amp;amp;address, sizeof(address)) &amp;lt; 0) {
		 	printf(&quot;connect failed\n&quot;);
		 	return -1;
		 } */
		//else {
			const char* buffer = &quot;hello Elaine&quot;;
			sendto(sockfd, buffer, strlen(buffer), 0, (sockaddr*)&amp;amp;address, sizeof(address));
		//}
		close(sockfd);
		return 0;

	}   
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;	// RECV  
	#include &amp;lt;sys/socket.h&amp;gt;
	#include &amp;lt;sys/types.h&amp;gt;
	#include &amp;lt;netinet/in.h&amp;gt;
	#include &amp;lt;arpa/inet.h&amp;gt;
	#include &amp;lt;assert.h&amp;gt;
	#include &amp;lt;stdio.h&amp;gt;
	#include &amp;lt;unistd.h&amp;gt;
	#include &amp;lt;stdlib.h&amp;gt;
	#include &amp;lt;errno.h&amp;gt;
	#include &amp;lt;string.h&amp;gt;
	#include &amp;lt;libgen.h&amp;gt;
	#include &amp;lt;iostream&amp;gt;
	using namespace std;

	#define BUFFER_SIZE 1024

	int main(int argc, char* argv[]) {
		if (argc &amp;lt;= 2) {
			printf(&quot;usage:%s ip_address, port number\n&quot;, basename(argv[0]));
			return 1;
		}
		const char* ip = argv[1];
		int port = atoi(argv[2]);

		struct sockaddr_in address;
		bzero(&amp;amp;address, sizeof(address));
		address.sin_family = AF_INET;
		inet_pton(AF_INET, ip , &amp;amp;address.sin_addr);
		address.sin_port = htons(port);			int sock = socket(AF_INET, SOCK_DGRAM, 0);
		assert(sock &amp;gt;= 0);

		int ret = bind(sock, (struct sockaddr*)&amp;amp;address, sizeof(address));
		assert(ret != -1);

		//ret = listen(sock, 5);

		struct sockaddr_in client;
		socklen_t client_addrlength = sizeof(client);
	
		/* int connfd = accept(sock, (struct sockaddr*)&amp;amp;client, &amp;amp;client_addrlength);
		 if (connfd &amp;lt; 0) {
		 	printf(&quot;errno is %d\n&quot;, errno);
		 }*/
		// else {
			char buffer[BUFFER_SIZE];
			memset(buffer,&#39;\0&#39;,sizeof(buffer));
			ret = recvfrom(sock, buffer, BUFFER_SIZE-1, 0, (struct sockaddr*)&amp;amp;client, &amp;amp;client_addrlength);
			printf(&quot;got %d bytes of udp data &#39;%s&#39; \n&quot;, ret, buffer);
		//}
		close(sock);
		return 0;
	}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;就当我在卖萌吧…&lt;/h2&gt;
</description>
        <pubDate>Tue, 09 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/12/09/SocketPractice1.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/12/09/SocketPractice1.html</guid>
        
        
      </item>
    
      <item>
        <title>Linux高性能服务器编程-读书笔记-CH5</title>
        <description>&lt;h1 id=&quot;linux&quot;&gt;Linux高性能服务器编程&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @2014.12.6&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;linuxapi&quot;&gt;第五章 Linux网络编程基础API&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;socket地址API  &lt;br /&gt;
  &amp;gt; * &lt;strong&gt;字节序&lt;/strong&gt;：大端：高位存在低地址；小端：低位存在低地址  ；&lt;br /&gt;
  &amp;gt; * 大多数PC采用小端字节序，因此小端字节序又称为主机字节序； &lt;br /&gt;
  &amp;gt; * 网络发送端总是把数据转换为大端字节序，接收端机器根据自己的字节序决定是否转换。大端字节序又称为网络字节序。 &lt;br /&gt;
  &amp;gt; * JAVA虚拟机采用大端字节序。   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;创建Socket    &lt;br /&gt;
  使用Linux系统调用即可，注意参数。    &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #include &amp;lt;sys/types.h&amp;gt;      
  int socket( int domain, int type, int protocol) ;     
  /* domain: 协议族 ；  
   * type: 服务类型；  
   * protocol: 具体的协议;   */
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;命名 Socket  &lt;br /&gt;
  将一个socket与socket地址绑定称为给socket命名。
  服务器程序中，只有命名后，客户端才知道如何连接它。  &lt;br /&gt;
  客户端不需要命名socket而是匿名，操作系统会自动分配socket地址。  &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #include &amp;lt;sys/types.h&amp;gt;   
  #include &amp;lt;sys/socket.h&amp;gt;   
  int bind( int sockfd, const struct sockaddr* my_addr, socklen_t addrlen );     
  /* 将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度。     
  * 失败时返回值：  EACCES: 被绑定的地址是受保护地址，进超级用户能够访问。EADDRINUSE：被绑定的地址正在使用中。*/        
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;监听 Socket &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #include &amp;lt;sys/socket.h&amp;gt;  
  int listen ( int sockfd, int backlog ) ;    
  /* sockfd: 被监听的socket    
   * backlog: 提示内核监听队列的最大长度  */     
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;接受连接  &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #include  &amp;lt;sys/types.h&amp;gt;   
  #include &amp;lt;sys/socket.h&amp;gt;   
  int accept ( int sockfd, struct sockaddr *addr, socklen_t *addrlen)   
  /* sockfd：执行通过listen系统调用的监听socket;   
   * addr: 用来获取被接受连接的远端socket地址；   
   * 成功时返回一个新的连接socket，唯一标识了被接收的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。*/       
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;发起连接  &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #include &amp;lt;sys/types.h&amp;gt;  
  #include &amp;lt;sys/socket.h&amp;gt;    
  int connect (int sockfd, const struct sockaddr *serv_addr, socklen_t addrlen);    
  /* sockfd: 由socket系统调用返回一个socket；   
   * serv_addr:服务器监听的socket地址；   
   * addrlen: 指定地址的长度；  */
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭连接  &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;   #include &amp;lt;unistd.h&amp;gt;   
   int close( int fd);   
   /* 每次调用，将fd引用次数减一；
    * 直到为0时，真正关闭连接 */     
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;      #include &amp;lt;sys/socket.h&amp;gt;   
      int shutdown( int sockfd, int howto );    
      /* 立即关闭连接。howto决定shutdown行为 */       
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数据读写 &lt;br /&gt;
  TCP数据读写   &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #include &amp;lt;sys/types.h&amp;gt; 
  #include &amp;lt;sys/socket.h&amp;gt;  
  ssize_t recv( int sockfd, void *buf, size_t len, int flags ); 
  ssize_t send( int sockfd, const void *buf, size_t len, int flag );     
&lt;/code&gt;&lt;/pre&gt;

    &lt;p&gt;通用数据读写  &lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;  #include &amp;lt;sys/socket.h&amp;gt;   
  ssize_t recvmsg(int sockfd, struct msghdr* msg,  int flags) 
  ssize_t sendmsg(int sockfd, struct msghdr* msg, int flags)     
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;Socket API太多了，不再赘述。其中很多参数必须要靠真正的编程实践才能体会其作用，等我的老联想本本的ubuntu装起了，好好写点代码实验下。有种老家伙迎来第二春的快感，毕竟已经废弃它了几个月了。&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 06 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/12/06/LearnLinux4.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/12/06/LearnLinux4.html</guid>
        
        
      </item>
    
      <item>
        <title>Linux高性能服务器编程-读书笔记-CH4</title>
        <description>&lt;h1 id=&quot;linux&quot;&gt;Linux高性能服务器编程&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @2014.12.2&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;tcpipinternetweb&quot;&gt;第4章 TCP/IP通信案例：访问Internet上的web服务器&lt;/h3&gt;

&lt;h4 id=&quot;section&quot;&gt;一些概念：&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;正向代理服务器：要求客户端自己设置代理服务器的地址。每次请求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。    &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;反向代理服务器：设置在服务器端，客户端无须进行任何设置。用代理服务器来接收Internet上的连接请求，将请求转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给客户端。   &lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;正向代理服务器与客户端在同一个逻辑网络中，反向代理服务器与服务器在同一个逻辑网络中。    &lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;透明代理服务器：只能设置在网关上。可看做正向代理的一种特殊情况。  &lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;代理服务器通常还提供缓存目标资源的功能。    &lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;http-&quot;&gt;HTTP服务 通信过程&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;访问DNS服务器     &lt;/li&gt;
  &lt;li&gt;本地名称查询    &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP通信    &lt;/p&gt;

    &lt;p&gt;HTTP请求：&lt;br /&gt;
  1. 短连接：请求处理完后立即关闭连接。同一个客户的多个HTTP请求不能共用一个TCP连接。&lt;br /&gt;
  2. 长连接：多个请求可以使用同一个TCP连接。极大减少了网络上由于建立TCP连接导致的负荷，减少处理时间。&lt;/p&gt;

    &lt;p&gt;HTTP应答：    &lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;100 continue  通知客户端继续发送数据；    &lt;br /&gt;
200 OK 请求成功； &lt;br /&gt;
3xx 重定向；&lt;br /&gt;
4xx 客户端错误； &lt;br /&gt;
5xx 服务器错误；&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;Cookie:&lt;br /&gt;
  HTTP的无状态特性（无上下文），使得交互程序不方便承上启下。cookie是服务器发送给客户端的特殊信息，客户端每次发送给服务器的请求都需要带上这些信息，服务器就可以区分不同客户，基于浏览器的自动登录就是用cookie实现的。   &lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 02 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/12/02/LearnLinux3.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/12/02/LearnLinux3.html</guid>
        
        
      </item>
    
      <item>
        <title>直面生死</title>
        <description>&lt;h1 id=&quot;section&quot;&gt;直面生死&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @2014-12-1   &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section-1&quot;&gt;&lt;em&gt;佛说，人生有八苦，生，老，病，死，爱别离，怨长久，求不得，放不下。&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;早就听说过这话，也一直记在心里，总在情绪低落的时候，拿出来佯装文艺。我一直觉得这样的智慧实在难得，人生之苦，莫过于此，却鲜有深思。昨天睡前，听了一期柯文哲的演讲&lt;a href=&quot;http://v.youku.com/v_show/id_XNjI5NDAzMzY0.html&quot;&gt;《生与死的智慧》&lt;/a&gt;，将生死讲的透彻，一下子才觉察，人生的所有痛苦，都源于对人生的无能为力，却又无法劝说自己坦然面对。   &lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;&lt;em&gt;生命花园中的园丁&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;柯文哲其人，我不多说，也不论他的政治身份和观点。只说他身为一个外科医生，面对的生死别离，就比我们常人要多得多。 我不敢说医生这个职业该让所有人肃然起敬，至少在我心中，他们是伟大而善良的群体，他们代表着希望。然而，纵然现代医学如何发达，总有解决不了的疑难杂症，总有无能为力的生命逝去。柯文哲说，“医生是生命花园中的园丁”，他们并不能改变生死的结局，而只能尽力，让每个人的活着的时候更加好看，因为人，固有一死。  &lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;&lt;em&gt;怎样才算活着&lt;/em&gt;&lt;/h3&gt;

&lt;p&gt;生老病死乃人之常情，人总在拼命改造世界，实际能改造的，也只是自己眼中的小世界，是人类自己的生活。人作为与地球上千千万万生命体从生物特征上来说平等的物种，逃不过一个生命体的自然规律。就像《超体》中所说，环境适宜的时候，细胞选择繁殖，而环境恶化的时候，细胞选择永生。佛家说生老病死是八苦之四，不过是因为凡人无法坦然面对这样的轮回，因为即使人心再伟大，每个人最关注的，始终是自己。这其实无论对错，只是人毕竟不是神，那些神祇，不过是人类理想的状态而已。   &lt;/p&gt;

&lt;p&gt;还好，人非草木，更非鸟兽，除了生命，人还有希望，人总是向往着更美好的事物，并且总有人，很可能是绝大多数人，相信着那些美好的事物总会到来。我想，这大概也是推动着人类不断去进步的源动力吧，生生不息的努力，为了在自己永生之后，让后代活的更加舒适，生命如此代代延续，使得人类成为了这地球上亿万年间的赢家，超越了其他仅仅停留在“活着”的层面的动物。    &lt;/p&gt;

&lt;p&gt;柯文哲在演讲中提了一个问题“怎样才算活着”。他说追求这个问题的答案的过程，本身就是这个问题的答案。Can’t agree more. 先哲对这个问题的追寻，使得后代们能够有巨人的肩膀得以立足，吾辈的奋斗和创造，得以使未来人加速前进。这种推动力带来的不是速度上的递增，而是加速度上的递增。正如祖先自拿起第一块石头作为工具使用，就已经开始了人类一发不可收拾的快马加鞭的进化。   &lt;/p&gt;

&lt;h3 id=&quot;an&quot;&gt;&lt;em&gt;A的N次方&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;人生再长不过百年，譬如朝露，去日苦多。朝露尚可滋润一方土地，养活几株花草，更何况仁慈的上天已经给了我们更多的时间和足够的机会，去更好的“活着”。愚钝的人，总有许多对生活的抱怨，总是贪心的想要更多，却忘记自己是否应得，平凡之人，在活着的时候立足于脚下之地，保自家安宁，去时也算无所遗憾，难怪一生平淡，好在自给自足也算自在，智者，懂得生死的道理，生之时不辞辛苦，奋斗不息，死之时坦然面对，心中安宁，他的智慧流传在人间，得以永生。   &lt;/p&gt;

&lt;p&gt;柯文哲说，“人生应该像A的N次方”，当你对社会的贡献大于索取，A就是大于1的，此时A的N次方趋向无穷大，社会就会越来越好，反之，A小于1时，A的N次方将会快速趋近于0，社会很快就会崩溃。   &lt;/p&gt;

&lt;p&gt;我不敢说人人都是积极向上的，但人这种生物，在进化的过程中，除了学会了希望，还学会了羞耻心。相信总有绝大多数的人，不会愿意去做那个拖后腿的，这也是人类得以进步的保障。   &lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;&lt;em&gt;最困难的不是面对各种挫折打击，而是面对各种挫折打击，却不失去对人世的热情&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;柯文哲以这句话作为演讲的结束语。  &lt;br /&gt;
年轻的时候，总探讨这些人生的大哲学是否太过老成？非也，传统观念中年迈之时才来讨论生死，正是因为我们绝大多数都是凡人，那时已有太多的无能为力。&lt;br /&gt;
所以能在初入社会的时候，就听到前辈这样的道理，并能从中领悟一二，也是一大幸运，不得不感谢这世上总有智者。  &lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;人总说“人生苦短”，其实我看来，苦不苦，要看以怎样的心态去面对生，短不短，要看你以怎样的心态面对死。&lt;/p&gt;

</description>
        <pubDate>Mon, 01 Dec 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/12/01/LiveAndDeath.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/12/01/LiveAndDeath.html</guid>
        
        
      </item>
    
      <item>
        <title>Linux高性能服务器编程-读书笔记-CH3</title>
        <description>&lt;h1 id=&quot;linux&quot;&gt;Linux高性能服务器编程&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @2014.11.30&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;tcp&quot;&gt;第三章 TCP协议详解&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;TCP服务的特点：&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;面向连接&lt;/strong&gt; 双方必须先建立连接，然后开始数据读写。全双工连接，双方数据读写可以通过一个连接进行，完成数据交换后，双方都必须断开连接。 
  基于广播和多播的应用不能使用TCP，应使用UDP。    &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;字节流&lt;/strong&gt; 发送端执行的写操作的次数和接收端执行的读操作次数之间没有固定的数量关系。&lt;strong&gt;应用程序对数据的发送何接收没有边界限制。&lt;/strong&gt;接收端应用程序可以一次读出TCP缓冲区的所有数据，也可分多次读取，取决于应用程序读缓冲区的大小。    &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;可靠的&lt;/strong&gt; 1.采用发送应答机制；2.超时重传机制；3.最终以IP数据报发送，TCP协议还会对报文段进行重排整理。  &lt;/p&gt;

        &lt;p&gt;&lt;em&gt;序号 ISN+首字偏移；&lt;/em&gt; &lt;br /&gt;
  &lt;em&gt;确认号 ACK=对方序号+1；用于对对方的响应确认。&lt;/em&gt; &lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;TCP连接的建立和关闭         &lt;br /&gt;
   连接建立：3次握手 &lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;主机1发送带有SYN标志的同步报文段，向主机2发起连接请求，该报文段包含一个序号；   &lt;/li&gt;
      &lt;li&gt;主机2发送自己的序号，并对主机1的报文段确认，确认值（ACK）为主机1的序号+1；   &lt;/li&gt;
      &lt;li&gt;主机1对主机2的报文段确认，TCP连接建立完成。      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;连接关闭：4次挥手    &lt;br /&gt;
  1. 主机1发送FIN给主机2，请求关闭连接； &lt;br /&gt;
  2. 主机2确认该报文段；
  3. 主机2发送自己的结束报文段； &lt;br /&gt;
  4. 主机1确认主机2的报文段。 &lt;br /&gt;
  &lt;strong&gt;连接关闭过程可能是客户端主动关闭，也可能是服务器执行主动关闭，也可能是同时关闭&lt;/strong&gt;    &lt;/p&gt;

    &lt;p&gt;半关闭状态
  TCP连接是全双工的，允许两个方向的数据传输被独立关闭。 &lt;br /&gt;
  服务器和客户端应用程序判断对方是否已经关闭连接的方法是： read系统调用返回0（收到结束报文段）。由于半关闭状态的存在，TCP连接断开需要4次挥手，双方都要确认对方已经关闭连接。        &lt;/p&gt;

    &lt;p&gt;连接超时 &lt;br /&gt;
  对于失败的连接，TCP会尝试重连，每次重连的超时时间增加1倍，多次重连失败后，放弃连接并通知应用程序。   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;TCP状态转移 &lt;br /&gt;
  TIME_WAIT状态 &lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;可靠的终止TCP连接；  &lt;/li&gt;
      &lt;li&gt;保证让迟来的TCP报文段有足够的时间被识别并丢弃。&lt;br /&gt;
  Linux系统中，一个TCP端口不能被同时打开多次。只有当前连接不在TIME_WAIT状态，即其连接的报文段已全部处理完毕，才能开启下一次连接。   &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;复位报文段     &lt;br /&gt;
  在某些情况下，TCP连接的一端会向另一端发送复位报文段，以通知对方关闭连接或重连。
    &lt;ol&gt;
      &lt;li&gt;访问端口不存在，或该端口处于TIME_WAIT状态 ；  &lt;/li&gt;
      &lt;li&gt;异常终止连接，一旦发送复位报文段，发送端所有排队的数据全丢弃；   &lt;/li&gt;
      &lt;li&gt;处理半打开连接，一方已关闭连接，另一方没有接到结束报文段而保持连接，此时保持连接的一方发送报文后，将收到复位报文段。   &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP交互数据流 &lt;br /&gt;
 适用于实时性要求高的应用程序或协议。
   Nagle算法： 要求TCP连接双方任意时刻最多只能发送一个未被确认的TCP报文段，在该报文段确认到达之前不能发送其他TCP报文段，在等待确认的同时，手机本端需要发送的微量数据，并在确认到来时，以一个TCP报文段全部发出，减少了网络上微小的TCP报文段数量。&lt;strong&gt;算法优点：确认到达的越快，数据也发送的越快。&lt;/strong&gt;      &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP成块数据流   &lt;br /&gt;
  适用于数据量大的应用程序或协议。&lt;br /&gt;
  发送端可以一次发送多个报文段，接收端可以一次确认多个报文段。能够发送多少与设置的通告窗口大小有关。  &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;带外数据   &lt;br /&gt;
  有些传输层协议有带外数据概念。用于迅速通告对方本方发生的重要事件。带外数据比普通数据有更高的优先级，总是立即被发送而不论缓冲区中是否有排队等待发送的普通数据。TCP有紧急指针标志和紧急指针两个字段，相当于带外数据。   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCP超时重传   &lt;br /&gt;
  超时发生后执行重传，每次超时时间都增加1倍，几次重传均失败后，由IP和ARP接管。 内核中有两个参数：1. 由IP接管前TCp最少执行的重传次数，默认3；2. 连接放弃前，TCP最多执行的重传次数，默认15。   &lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;拥塞控制  &lt;br /&gt;
  拥塞控制最终控制的变量是发送端一次性向网络写入的数据量，即SWND发送窗口。SWND限定了发送端能连续发送的TCP报文段数量。    &lt;br /&gt;
  SWND太小，引起明显的网络延迟，反之则易导致网络拥塞。实际SWND值是RWND（接收方的接收通告窗口）和CWND（发送端拥塞窗口）中的较小者。 &lt;br /&gt;
    &lt;ol&gt;
      &lt;li&gt;慢启动、拥塞避免；
  慢启动的TCP的拥塞窗口一开始是探测性增长的，慢启动会导致拥塞窗口快速膨胀，导致网络拥塞，因此设定慢启动门限值，CWND超过该值时，TCP拥塞控制进入拥塞避免阶段。&lt;br /&gt;
  &amp;gt;判断拥塞发生的依据：1.传输超时，或者TCP重传定时器溢出。 2.接收到重复的确认报文段。   &lt;br /&gt;
  &amp;gt;情况1采用慢启动和拥塞避免来处理；情况2使用快速重传和快速恢复来处理。若情况2发生在重传定时器溢出之后，则按照情况1处理。         &lt;/li&gt;
      &lt;li&gt;快速重传和快速恢复  &lt;br /&gt;
  判断是否真正发生拥塞：若发送端连续收到3个重复的确认报文段，则认为是拥塞。  &lt;br /&gt;
  处理方法：&lt;br /&gt;
  1）当收到3个重复的确认报文段，重新计算慢启动门限，然后立即重传丢失的报文段，并重新设置CWND。&lt;br /&gt;
  2）每次收到1个重复的确认，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段。&lt;br /&gt;
  3）当收到新数据的确认时，设置CWND为新的慢启动门限。   &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 30 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/11/30/LearnLinux2.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/11/30/LearnLinux2.html</guid>
        
        
      </item>
    
      <item>
        <title>Linux高性能服务器编程-读书笔记-CH2</title>
        <description>&lt;h1 id=&quot;linux&quot;&gt;Linux高性能服务器编程&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Edit by Elaine @2014.11.28     &lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;ip&quot;&gt;第二章 IP协议详解&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;IP服务的特点 &lt;br /&gt;
  &lt;strong&gt;无状态&lt;/strong&gt;（通信双方不同步传输数据的状态信息）可能是乱序、重复的数据     &lt;br /&gt;
      优点：简单高效
  &lt;strong&gt;无连接&lt;/strong&gt;（通信双方不长久维持对方的任何信息）每次发送都必须指明IP  &lt;br /&gt;
  &lt;strong&gt;不可靠&lt;/strong&gt;（不能保证IP数据报准确的到达接收端）上层需要自己实现数据确认，超时重传等      &lt;/li&gt;
  &lt;li&gt;IP转发&lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;检查数据报头部TTL值，若为0，丢弃数据报；&lt;/li&gt;
      &lt;li&gt;查看路由选择新安乡，若设置了该选项，则检查数据报的目标IP地址是否为本机的某个IP地址，若不是，则发送ICMP源站选路失败报文给发送端；  &lt;/li&gt;
      &lt;li&gt;若有必要，则发源端一个ICMP重定向报文，告诉它一个更合理的下一跳路由器；   &lt;/li&gt;
      &lt;li&gt;TTL值-1；  &lt;/li&gt;
      &lt;li&gt;处理IP头部选项；   &lt;/li&gt;
      &lt;li&gt;若有必要，执行IP分片操作；   &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;
IPV6并不是IPV4的简单扩展，而是完全不同的协议， 除了解决IP不够用的问题，还增加了多播和流的功能，引入了自动配置功能，增加专门的网络安全功能等。   
&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 28 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/11/28/LearnLinux1.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/11/28/LearnLinux1.html</guid>
        
        
      </item>
    
      <item>
        <title>黑客与画家-读书笔记</title>
        <description>&lt;h1 id=&quot;paul-graham&quot;&gt;黑客与画家 · Paul Graham&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;edit by Elaine -2014-11-09    &lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;程序是写给人看的，附带能在机器上运行。  &lt;/li&gt;
  &lt;li&gt;触怒他人的言论是那些可能会有人相信的言论。  最令人暴跳如雷的言论，就是被认为说出了真相的言论。    &lt;/li&gt;
  &lt;li&gt;自由思考比畅所欲言更重要。    &lt;/li&gt;
  &lt;li&gt;如果自己就是潮水的一部分，怎么能看见潮流的方向呢？你只能永远保持质疑。  &lt;/li&gt;
  &lt;li&gt;安全问题的关键在于不要有漏洞，而不是任何设计上的决策。  &lt;/li&gt;
  &lt;li&gt;财富才是你的目标，金钱不是。  金钱是财富的一种简便的表达方式。  &lt;/li&gt;
  &lt;li&gt;好设计是简单的设计。当你被迫把东西做得很简单时，你就被迫直接面对真正的问题。&lt;/li&gt;
  &lt;li&gt;软件的难题通常可以被改成等价的较易解决的形式。&lt;/li&gt;
  &lt;li&gt;并非所有的艰苦都是值得的。世界上有有益的痛苦，也有无益的痛苦。你需要的是咬牙向前冲刺的痛苦，而不是脚被钉子扎破的痛苦。&lt;/li&gt;
  &lt;li&gt;在大多数领域，看上去容易的事情，背后都需要大量的练习。练习的作用也许是训练你把刻意为之的事情变成一种自觉的行为。&lt;/li&gt;
  &lt;li&gt;我想，最伟大的大师最终会达到一种超脱自我的境界。他们一心想找到正确答案，如果别人已经回答出了一部分，那就没理由不拿来用。他们足够自信地使用他人的成果，完全不担心因此丧失个人的特点。&lt;/li&gt;
  &lt;li&gt;推动人才成批涌现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。在历史的任何时刻都有一些热点项目，一些团体在这些项目上做出伟大的成绩。如果你远离这些中心，几乎不可能单靠自己就取得伟大成果。&lt;/li&gt;
  &lt;li&gt;单单是无法容忍丑陋的东西还不够，只有对这个领域非常熟悉，你才可能发现哪些地方可以动手改进。你必须锻炼自己。只有在成为某个领域的专家之后，你才会听到心里有一个细微的声音说：“这样解决太糟糕了！一定有更好的选择。”不要忽视这种声音，要培育它们。优秀作品的秘诀就是：非常严格的品味，再加上实现这种品味的能力。  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Thu, 27 Nov 2014 00:00:00 +0800</pubDate>
        <link>http://yourdomain.com/2014/11/27/Hacker.html</link>
        <guid isPermaLink="true">http://yourdomain.com/2014/11/27/Hacker.html</guid>
        
        
      </item>
    
  </channel>
</rss>
